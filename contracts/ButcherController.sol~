pragma solidity ^0.8.1;
/**
 * The BadButcherController is an upgradeable endpoint for controlling BadButcher.sol. It is copied from --> Folia's DecomposerController.sol
 * The FoliaControllerV2 is an upgradeable endpoint for controlling Folia.sol
 */
/*
import "./BadButcher.sol";
import "./SafeMath.sol";
import "./Ownable.sol";
import "./ReentrancyGuard.sol";
import "./IERC721.sol";
import "./IERC165.sol";


contract ButcherController is Ownable, ReentrancyGuard {

    using SafeMath for uint256;

    event newContract(address contractAddress);
    event deletedContract(address contractAddress);
    event editionBought(address contractAddress, uint256 tokenId, uint256 newTokenId);
    uint256 public price = 8 * (10**16); // 0.08 Eth
    uint256 public totalMax = 888;
    mapping(address => uint256) public editionsLeft;

    BadButcher public badbutcher;

    uint256 public adminSplit = 20;
    address payable public adminWallet;
    address payable public artistWallet;
    bool public paused;

    modifier notPaused() {
        require(!paused, "Must not be paused");
        _;
    }

    constructor(
        BadButcher _badbutcher,
        address payable _adminWallet
    ) public {
        badbutcher = _badbutcher;
        adminWallet = _adminWallet;
        // uint256 _maxEditions = 88;

    }


    // can be re-used as an "updateContractEditionSize"
    function addContract(address contractAddress) public onlyOwner {
      
      emit newContract(contractAddress);
    }
    
    function removeContract(address contractAddress) public onlyOwner {
      emit deletedContract(contractAddress);
    }

    function updateArtworkPrice(uint256 _price) public onlyOwner {
      price = _price;
    }

    function updateArtistWallet(address payable _artistWallet) public onlyOwner {
      artistWallet = _artistWallet;
    }

    function updateTotalMax(uint256 _totalMax) public onlyOwner {
      totalMax = _totalMax;
    }

    function buy(address recipient, address contractAddress, uint256 tokenId) public payable notPaused nonReentrant returns(bool) {

        require(msg.value == price, "Wrong price paid");

        uint256 newTokenId = uint256(keccak256(abi.encodePacked(contractAddress, tokenId)));
        badbutcher.mint(recipient, newTokenId);

        uint256 adminReceives = msg.value.mul(adminSplit).div(100);
        uint256 artistReceives = msg.value.sub(adminReceives);

        (bool success, ) = adminWallet.call.value(adminReceives)("");
        require(success, "admin failed to receive");

        (success, ) = artistWallet.call.value(artistReceives)("");
        require(success, "artist failed to receive");

        emit editionBought(contractAddress, tokenId, newTokenId);
    }

    function updateAdminSplit(uint256 _adminSplit) public onlyOwner {
        require(_adminSplit <= 100, "SPLIT_MUST_BE_LTE_100");
        adminSplit = _adminSplit;
    }

    function updateAdminWallet(address payable _adminWallet) public onlyOwner {
        adminWallet = _adminWallet;
    }

    function updatePaused(bool _paused) public onlyOwner {
        paused = _paused;
    }
}
*/